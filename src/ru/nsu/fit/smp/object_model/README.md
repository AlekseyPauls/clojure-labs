# Object model

## Требования:
1. Определите для языка Clojure объектную модель. Обеспечите поддержку следующих элементов:
    * класс;
    * атрибут (свойство, слот);
    * множественное наследование (в предположении что все ветки не пересекаются по атрибутам и методам);
    * диспетчеризацию обработки сообщений относительно одного аргумента (динамический полиморфизм).

2. Определите соответствующие функции и/или макросы для работы с перечисленными выше элементами.

## Дополнительные требования
Определите поддержку следующих элементов:
* множественное наследование;
* диспетчеризацию обработки сообщений в иерархии с множественным наследованием (классов или примесей); 
реализуйте аналог call-next-method из CLOS (с фиксированной стратегией диспетчеризации по одному параметру);
* включите вспомогательные методы (before, after) в механизм диспетчеризации;
* обобщенные функции (диспетчеризация по нескольким параметрам);
* поддержка изменяемого состояния на основе транзакционной памяти (можноиспользовать встроенную в Clojure 
поддержку STM); обеспечьте реализацию принципа Command-Query Separation на уровне декларации классов 
(и/или других элементов объектной модели).
* статическая типизация.

## Описание сделанной работы

На данный момент реализованы все базовые требования.

## Описание некоторых моментов

**Иерархия классов:** мы храним иерархию классов в Ref и в самом начале специально вручную
 помещаем класс Object в пустую иерархию классов. Ref изменяется с помощью транзакций
 
**def-class** - почти аналогично лекции, но суперклассы помещаются в список (одноэлементный, если класс один)

**has-field?** - просто рекурсивная проверка, что поле содержится в классе или одном из его суперклассов.
Так как статической типизации пока нет, пересечение полей у классов не является проблемой

**dispatch** - механизм диспетчеризации методов. Ищет в таблице виртуальных функций для одного метода 
наиболее подходящуюю функцию с учетом входного типа данных. Если функция не найдена, бросает ексепшн.
Работает самым простым образом - берет порядок обхода суперклассов и выдает первый подходящий класс + 
функцию для него. То есть, порядок объявления суперклассов имеет значение

**perform-effective-command** - по факту просто находит через dispatch функцию и применяет ее, 
но в процессе создает биндинг на слово **super** аналогичной функции для супекласса эффективного класса 
(эффективный класс - это сам данный класс или его наследник, для которого нашлась функция). 
Это пока не используется, но пригодится для выполнения дополнительных заданий 

**perform-effective-query** - аналогично perform-effective-command, только вызываемая функция не меняет 
состояния объекта и поэтому вызывается не как транзакция

**def-command** - макрос для создания функций. Генерирует код для функции, в котором инициализируется 
 таблица виртуальных функций (Ref) и есть два режима:
 1. Вызов - если первый аргумент объект, то это просто вызов функции и нужно найти и применить подходящую 
 для типа переданного объекта функцию, используя таблицу виртуальных функций
 2. Регистрация - добавляет в таблицу виртуальных функций новую функцию 
 
 Есть проверка, переопределяется ли название функции. То есть, нельзя 2 раза вызвать **def-command**
 с одним названием функции. Но можно несколько раз делать **def-method** с одной комбинацией параметров - 
 возможность переопределить реализацию функции для конкретного класса рассматривалась на лекции как фича

**def-query** - то же, что и предыдущий макрос, но для поиска и вызофа функции используется 
**perform-effective-query**

**def-method** - вызывает код, сгенерированный **def-command** или **def-query** в режиме регистрации